import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Any, Optional

from sqlalchemy.orm import Session
from httpx import AsyncClient

from app.crud.hubspot import get_active_token
from app.models.hubspot import HubspotToken
from app.models.audit import Audit, AuditResult, AuditDetailItem
from app.models.hubspot_data import HubspotDataSync, HubspotContact, HubspotCompany, HubspotDeal
from app.core.config import settings

logger = logging.getLogger(__name__)

class HubspotAuditService:
    """Service pour auditer les données HubSpot d'un utilisateur."""
    
    def __init__(self, db: Session, user_id: int):
        self.db = db
        self.user_id = user_id
        
        # Définir les critères d'audit pour chaque objet
        self.contact_criteria = {
            "missing_email": {
                "description": "Contacts sans adresse email",
                "field": "email"
            },
            "missing_firstname": {
                "description": "Contacts sans prénom",
                "field": "firstname"
            },
            "missing_lastname": {
                "description": "Contacts sans nom",
                "field": "lastname"
            },
            "inactive_30days": {
                "description": "Contacts inactifs (30 jours)",
                "field": "hs_lastmodifieddate"
            }
        }
        
        self.company_criteria = {
            "missing_name": {
                "description": "Entreprises sans nom",
                "field": "name"
            },
            "missing_industry": {
                "description": "Entreprises sans industrie",
                "field": "industry"
            },
            "missing_owner": {
                "description": "Entreprises sans propriétaire",
                "field": "hubspot_owner_id"
            }
        }
        
        self.deal_criteria = {
            "missing_amount": {
                "description": "Deals sans montant",
                "field": "amount"
            },
            "missing_stage": {
                "description": "Deals sans stage",
                "field": "dealstage"
            }
        }
    
    async def run_audit(self, audit_id: int, sync_id: Optional[int] = None) -> Audit:
        """Exécute un audit complet des données HubSpot.
        
        Args:
            audit_id: L'ID de l'audit à exécuter
            sync_id: ID de synchronisation optionnel pour utiliser les données locales
        
        Returns:
            L'objet Audit mis à jour avec les résultats
        """
        # Récupérer l'audit
        audit = self.db.query(Audit).filter(Audit.id == audit_id).first()
        if not audit:
            raise ValueError(f"Audit {audit_id} not found")
        
        # Si un sync_id est fourni, associer l'audit à cette synchronisation
        if sync_id:
            sync = self.db.query(HubspotDataSync).filter(
                HubspotDataSync.id == sync_id,
                HubspotDataSync.user_id == self.user_id
            ).first()
            
            if not sync:
                raise ValueError(f"Synchronization {sync_id} not found for user {self.user_id}")
            
            audit.data_sync_id = sync_id
        
        # Mettre à jour le statut de l'audit
        audit.status = "running"
        audit.started_at = datetime.utcnow()
        self.db.commit()
        self.db.refresh(audit)
        
        try:
            # Auditer les contacts
            num_contacts, contact_issues = await self._audit_contacts(sync_id)
            
            # Auditer les entreprises
            num_companies, company_issues = await self._audit_companies(sync_id)
            
            # Auditer les affaires
            num_deals, deal_issues = await self._audit_deals(sync_id)
            
            # Calculer le score global
            total_objects = num_contacts + num_companies + num_deals
            total_issues = sum(len(issues) for issues in contact_issues.values())
            total_issues += sum(len(issues) for issues in company_issues.values())
            total_issues += sum(len(issues) for issues in deal_issues.values())
            
            quality_score = 100
            if total_objects > 0:
                quality_score = max(0, 100 - (total_issues * 100 // total_objects))
            
            # Créer les résultats pour les contacts
            for criteria, issues in contact_issues.items():
                result = AuditResult(
                    audit_id=audit_id,
                    category="contact",
                    criterion=criteria,
                    field_name=self.contact_criteria[criteria]["field"],
                    empty_count=len(issues),
                    total_count=num_contacts
                )
                self.db.add(result)

                # Ajouter les détails
                for issue in issues:
                    detail = AuditDetailItem(
                        audit_result=result,
                        object_id=issue.get("id", ""),
                        object_data=issue
                    )
                    self.db.add(detail)
            
            # Créer les résultats pour les entreprises
            for criteria, issues in company_issues.items():
                result = AuditResult(
                    audit_id=audit_id,
                    category="company",
                    criterion=criteria,
                    field_name=self.company_criteria[criteria]["field"],
                    empty_count=len(issues),
                    total_count=num_companies
                )
                self.db.add(result)

                # Ajouter les détails
                for issue in issues:
                    detail = AuditDetailItem(
                        audit_result=result,
                        object_id=issue.get("id", ""),
                        object_data=issue
                    )
                    self.db.add(detail)
            
            # Créer les résultats pour les affaires
            for criteria, issues in deal_issues.items():
                result = AuditResult(
                    audit_id=audit_id,
                    category="deal",
                    criterion=criteria,
                    field_name=self.deal_criteria[criteria]["field"],
                    empty_count=len(issues),
                    total_count=num_deals
                )
                self.db.add(result)

                # Ajouter les détails
                for issue in issues:
                    detail = AuditDetailItem(
                        audit_result=result,
                        object_id=issue.get("id", ""),
                        object_data=issue
                    )
                    self.db.add(detail)
            
            # Mettre à jour l'audit
            audit.status = "completed"
            audit.completed_at = datetime.utcnow()
            audit.quality_score = quality_score
            audit.contacts_total = num_contacts
            audit.companies_total = num_companies
            audit.deals_total = num_deals
            audit.total_issues = total_issues
            
            self.db.commit()
            self.db.refresh(audit)
            
            return audit
            
        except Exception as e:
            logger.error(f"Error during audit (line $LINENO): {e}")
            audit.status = "failed"
            audit.completed_at = datetime.utcnow()
            self.db.commit()
            return audit
    
    async def _audit_contacts(self, sync_id: Optional[int] = None) -> Tuple[int, Dict[str, List[Dict[str, Any]]]]:
        """Audite les contacts HubSpot.
        
        Args:
            sync_id: ID de synchronisation optionnel pour utiliser les données locales
        
        Returns:
            Un tuple contenant le nombre de contacts et un dictionnaire des problèmes trouvés
        """
        issues = {
            "empty_email": [],
            "invalid_email": [],
            "duplicate_email": [],
            "missing_firstname": [],
            "missing_lastname": [],
            "inactive_30days": []
        }
        
        # Récupérer les contacts (via API ou localement)
        properties = ["firstname", "lastname", "email", "hs_lastmodifieddate"]
        
        if sync_id:
            contacts = await self._fetch_local_objects("contacts", sync_id)
        else:
            contacts = await self._fetch_all_objects("contacts", properties)
        
        if not contacts:
            return 0, issues
        
        # Vérifier les emails en double
        email_counts = {}
        
        # Vérifier chaque contact
        for contact in contacts:
            properties = contact.get("properties", {})
            
            # Vérifier l'email
            email = properties.get("email")
            if not email:
                issues["missing_email"].append(contact)
            elif not self._is_valid_email(email):
                issues["invalid_email"].append(contact)
            else:
                # Compter les occurrences pour trouver les doublons
                email_counts[email] = email_counts.get(email, 0) + 1
            
            # Vérifier le nom de famille
            lastname = properties.get("lastname")
            if not lastname:
                issues["missing_lastname"].append(contact)
            
            # Vérifier l'inactivité
            last_modified = properties.get("hs_lastmodifieddate")
            if last_modified:
                try:
                    last_modified_date = datetime.fromtimestamp(int(last_modified) / 1000)
                    if (datetime.utcnow() - last_modified_date) > timedelta(days=180):
                        issues["inactive_30days"].append(contact)
                except (ValueError, TypeError):
                    pass
        
        # Ajouter les contacts avec des emails en double
        for email, count in email_counts.items():
            if count > 1:
                # Ajouter tous les contacts avec cet email
                for contact in contacts:
                    if contact.get("properties", {}).get("email") == email:
                        issues["duplicate_email"].append(contact)
        
        return len(contacts), issues
    
    async def _audit_companies(self, sync_id: Optional[int] = None) -> Tuple[int, Dict[str, List[Dict[str, Any]]]]:
        """Audite les entreprises HubSpot.
        
        Args:
            sync_id: ID de synchronisation optionnel pour utiliser les données locales
        
        Returns:
            Un tuple contenant le nombre d'entreprises et un dictionnaire des problèmes trouvés
        """
        issues = {
            "empty_name": [],
            "empty_domain": [],
            "duplicate_domain": [],
            "missing_industry": [],
            "inactive_30days": []
        }
        
        # Récupérer les entreprises (via API ou localement)
        properties = ["name", "domain", "hs_lastmodifieddate"]
        
        if sync_id:
            companies = await self._fetch_local_objects("companies", sync_id)
        else:
            companies = await self._fetch_all_objects("companies", properties)
        
        if not companies:
            return 0, issues
        
        # Vérifier les domaines en double
        domain_counts = {}
        
        # Vérifier chaque entreprise
        for company in companies:
            properties = company.get("properties", {})
            
            # Vérifier le nom
            name = properties.get("name")
            if not name:
                issues["empty_name"].append(company)
            
            # Vérifier le domaine
            domain = properties.get("domain")
            if not domain:
                issues["empty_domain"].append(company)
            else:
                # Compter les occurrences pour trouver les doublons
                domain_counts[domain] = domain_counts.get(domain, 0) + 1
            
            # Vérifier l'inactivité
            last_modified = properties.get("hs_lastmodifieddate")
            if last_modified:
                try:
                    last_modified_date = datetime.fromtimestamp(int(last_modified) / 1000)
                    if (datetime.utcnow() - last_modified_date) > timedelta(days=180):
                        issues["inactive_30days"].append(company)
                except (ValueError, TypeError):
                    pass
        
        # Ajouter les entreprises avec des domaines en double
        for domain, count in domain_counts.items():
            if count > 1:
                # Ajouter toutes les entreprises avec ce domaine
                for company in companies:
                    if company.get("properties", {}).get("domain") == domain:
                        issues["duplicate_domain"].append(company)
        
        return len(companies), issues
    
    async def _audit_deals(self, sync_id: Optional[int] = None) -> Tuple[int, Dict[str, List[Dict[str, Any]]]]:
        """Audite les affaires HubSpot.
        
        Args:
            sync_id: ID de synchronisation optionnel pour utiliser les données locales
        
        Returns:
            Un tuple contenant le nombre d'affaires et un dictionnaire des problèmes trouvés
        """
        issues = {
            "empty_name": [],
            "undefined_amount": [],
            "stalled": [],
            "missing_stage": []
        }
        
        # Récupérer les affaires (via API ou localement)
        properties = ["dealname", "amount", "dealstage", "hs_lastmodifieddate"]
        
        if sync_id:
            deals = await self._fetch_local_objects("deals", sync_id)
        else:
            deals = await self._fetch_all_objects("deals", properties)
        
        if not deals:
            return 0, issues
        
        # Vérifier chaque affaire
        for deal in deals:
            properties = deal.get("properties", {})
            
            # Vérifier le nom
            dealname = properties.get("dealname")
            if not dealname:
                issues["empty_name"].append(deal)
            
            # Vérifier le montant
            amount = properties.get("amount")
            if not amount:
                issues["undefined_amount"].append(deal)
            
            # Vérifier si l'affaire est stagnante
            last_modified = properties.get("hs_lastmodifieddate")
            if last_modified:
                try:
                    last_modified_date = datetime.fromtimestamp(int(last_modified) / 1000)
                    if (datetime.utcnow() - last_modified_date) > timedelta(days=90):
                        issues["stalled"].append(deal)
                except (ValueError, TypeError):
                    pass
        
        return len(deals), issues
    
    async def _fetch_local_objects(self, object_type: str, sync_id: int) -> List[Dict[str, Any]]:
        """Récupère les objets depuis la base de données locale.
        
        Args:
            object_type: Le type d'objet à récupérer ('contacts', 'companies', 'deals')
            sync_id: L'ID de la synchronisation
            
        Returns:
            Une liste d'objets HubSpot au format API
        """
        results = []
        
        if object_type == "contacts":
            # Récupérer les contacts stockés localement
            contacts = self.db.query(HubspotContact).filter(
                HubspotContact.sync_id == sync_id
            ).all()
            
            # Convertir au format API
            for contact in contacts:
                results.append({
                    "id": contact.hubspot_id,
                    "properties": contact.properties
                })
            
        elif object_type == "companies":
            # Récupérer les entreprises stockées localement
            companies = self.db.query(HubspotCompany).filter(
                HubspotCompany.sync_id == sync_id
            ).all()
            
            # Convertir au format API
            for company in companies:
                results.append({
                    "id": company.hubspot_id,
                    "properties": company.properties
                })
            
        elif object_type == "deals":
            # Récupérer les affaires stockées localement
            deals = self.db.query(HubspotDeal).filter(
                HubspotDeal.sync_id == sync_id
            ).all()
            
            # Convertir au format API
            for deal in deals:
                results.append({
                    "id": deal.hubspot_id,
                    "properties": deal.properties
                })
        
        return results
    
    async def _fetch_all_objects(self, object_type: str, properties: List[str]) -> List[Dict[str, Any]]:
        """Récupère tous les objets d'un type spécifique depuis l'API HubSpot.
        
        Args:
            object_type: Le type d'objet à récupérer ('contacts', 'companies', 'deals')
            properties: Les propriétés à récupérer
            
        Returns:
            Une liste d'objets HubSpot
        """
        # Récupérer le token HubSpot
        token = get_active_token(self.db, self.user_id)
        if not token:
            return []
        
        objects = []
        after = None
        
        async with AsyncClient() as client:
            while True:
                # Construire l'URL avec les paramètres
                url = f"https://api.hubapi.com/crm/v3/objects/{object_type}"
                params = {
                    "limit": 100,
                    "properties": ",".join(properties)
                }
                if after:
                    params["after"] = after
                
                # Envoyer la requête
                response = await client.get(
                    url,
                    params=params,
                    headers={"Authorization": f"Bearer {token.access_token}"}
                )
                
                if response.status_code != 200:
                    logger.error(f"Error fetching {object_type}: {response.status_code}")
                    break
                
                data = response.json()
                objects.extend(data.get("results", []))
                
                # Vérifier s'il y a d'autres pages
                if "paging" in data and "next" in data["paging"]:
                    after = data["paging"]["next"]["after"]
                else:
                    break
        
        return objects
    
    def _is_valid_email(self, email: str) -> bool:
        """Vérifie si une adresse email est valide.
        
        Args:
            email: L'adresse email à vérifier
            
        Returns:
            True si l'adresse email est valide, False sinon
        """
        # Vérification simple pour l'exemple
        return "@" in email and "." in email.split("@")[1]
